---
title: "ProyectoTD2025"
author: "Grupo G"
date: "2025-04-13"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Introducción

Relización del proyecto en la asignatura: Tratamiento de los Datos, del grado de Ciencia de Datos del primer curso. La finalidad de este proyecto es la realización de un análisis exploratorio de los datos que se han recopilado en varios tickets de Mercadona.

## Importación

```{r setup, cache = F, echo = F, message = F, warning = F, tidy = F}
# CONFIGURACIÓN GENERAL
library(knitr)
options(width = 100)
# Opciones generales chunks
opts_chunk$set(echo = T, message = F, error = F, warning = F,
               comment = NA, fig.align = 'center', dpi = 100, tidy = F,
               cache.path = '.cache/', fig.path = './figure/')
# options(xtable.type = 'html')
knit_hooks$set(inline = function(x) {
  if(is.numeric(x)) {
    round(x, getOption('digits'))
  } else {
    paste(as.character(x), collapse = ', ')
  }
})
# knit_hooks$set(plot = knitr:::hook_plot_html)
knitr::opts_chunk$set(fig.width=8, fig.height=4)
```

```{r eval = FALSE, include = FALSE}
# Especificamos las librerías necesarias en esta lista
packages = c("tidyverse", "knitr", "ggplot2", "datasets", "RColorBrewer","nycflights13")
# use this function to check if each package is on the local machine
# if a package is installed, it will be loaded
# if any are not, the missing package(s) will be installed and loaded
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
    library(x, character.only = TRUE)
  }
})
# verify they are loaded
search()
```


```{r, echo =FALSE, warning=FALSE, message=FALSE}
#Cargamos libreria pracma y los paquetes
library(pracma)
library(pdftools)
library('ggplot2') # visualization
library('dplyr') # data manipulation
library('tidyr') # data manipulation
library('readr') # data input
library('stringr') # string manipulation
library('forcats') # factor manipulation
library('modelr') # factor manipulation
```

Una vez cargadas las librerías necesarias, se procederá a importar los datos. Para ello, se obtiene el listado de todos los tickets ubicados en una carpeta específica.

```{r, echo =FALSE, warning=FALSE, message=FALSE}
# Guardamos en la variable directorio, la ruta de la carpeta con los ficheros que más tarde utilizaremos
directorio <- "./data"

# Guardamos en la variable 'tickets' todos los archivos contenidos en esta carpeta, que en este caso corresponden a los tickets de compra.
tickets <- list.files(directorio, full.names = TRUE)
```


La lectura de un ticket se organiza en una función que sigue varios pasos. Primero, se establece la codificación en UTF-8 para evitar errores posteriores, ya que algunos archivos pueden tener formatos diferentes.

A continuación, se analiza la cabecera del recibo, asignando cada línea a una variable: nombre del supermercado, dirección, etc. En ciertos casos, una línea puede contener varios datos, como la fecha y la hora, que separaremos más adelante.

Con esta información se crea un primer dataframe. Luego se extraen los productos del ticket para construir un segundo conjunto de datos. Finalmente, se añade el total de la compra, que suele aparecer tras los productos, al dataframe principal por tratarse de un valor único por ticket.

```{r, echo =FALSE, warning=FALSE, message=FALSE}

#Funcion que lee un archivo de ticket y extrae su información principal: cabecera, productos y total de compra, y la devuelve a modo de data frame
leer_ticket <- function(archivo) {
  library(pdftools)

  #Leer y limpiar el contenido del PDF
  contenido <- pdf_text(archivo)
  contenido <- strsplit(contenido, "\n")[[1]]
  contenido <- trimws(contenido)
  contenido <- contenido[contenido != ""]
  
  #Establecer codificación en UTF-8
  contenido <- iconv(contenido, to = "UTF-8")

  #Buscamos la primera aparición de la palabra "TOTAL" para cortar el ticket hasta esa línea
  total <- grep("TOTAL", contenido)[1]

  
  if (is.na(total)) {
  warning(paste("No se encontró 'TOTAL' en el archivo:", archivo))
  return(NULL)
  }
  
  contenido_ticket <- contenido[1:total]
  
  #Asignación de las primeras líneas del ticket -> info. común en tickets
  supermercado <- contenido_ticket[1]
  calle <- contenido_ticket[2]
  ubicacion <- contenido_ticket[3]
  telefono <- contenido_ticket[4] 
  fecha <- contenido_ticket[5]
  
  #Extraer productos desde la línea 8 hasta anres de "TOTAL"
  l_producto <- 8:(length(contenido_ticket)-1)
  producto<- contenido_ticket[l_producto]
  
  #Importe total de la compra
  importe_total <- contenido_ticket[length(contenido_ticket)]
  
  #Creación data frame
  data_frame <- data.frame(Supermercado = supermercado,
                               Calle = calle,
                               Ubicacion = ubicacion,
                               Telefono = telefono,
                               Fecha = fecha,
                               Producto = producto,
                               Total = total)

  return(data_frame)
}


```


El siguiente paso consiste en generar una lista con todos los tickets disponibles y aplicar sobre cada uno la función definida anteriormente.

```{r, echo =FALSE, warning=FALSE, message=FALSE}
#Inicializamos una lista vacía
lista <- list()

#Iteración sobre cada ticket
for (ticket in tickets) {
  data_temporal <- leer_ticket(ticket)
  lista[[length(lista) + 1]] <- data_temporal
}
```

Una vez procesados los tickets, se unifican los dataframes y se separan las variables combinadas, como la ubicación o la fecha y hora, en columnas independientes.

```{r, echo =FALSE, warning=FALSE, message=FALSE}
#Unión de todos los df de la lista
df <- bind_rows(lista)

#Ubicación -> CP y Ubicacion
df <- separate(df, Ubicacion, into = c("CP", "Ubicacion"), sep = " ")

# Fecha -> Fecha y Hora
df <- separate(df, Fecha, into = c("Fecha", "Hora"), sep = " ")
```

La importación continúa separando cantidad, producto y precio en un nuevo dataframe, que luego se une con el de cabeceras para relacionar cada producto con su compra correspondiente.

```{r, echo =FALSE, warning=FALSE, message=FALSE}

df <- separate(df, Producto, into = c("Cantidad", "Producto"), 
               sep = "(?<=.)(?=.)", extra = "merge")

df$precio_prod <- substr(df$Producto, nchar(df$Producto) - 3,
                             nchar(df$Producto))

df$Producto <- substr(df$Producto, 1, nchar(df$Producto) - 4)

df$precio_prod <- as.numeric(gsub(",", ".", df$precio_prod))

cabecera <- df %>% select(Supermercado, Calle, CP, Ubicacion, Telefono, Fecha, Hora, Total)
```

A continuación, se analiza la presencia del parking en los tickets, creando una variable que indica si aparece o no, y se incorpora al dataframe principal junto a las cabeceras, productos y tota

```{r, echo =FALSE, warning=FALSE, message=FALSE}

df <- df %>%
  mutate(parking = grepl("PARKING", Producto, ignore.case = TRUE))

df$Total <- gsub("[^0-9,]", "", df$Total)

df$Total <- as.numeric(gsub(",", ".", df$Total))

df <- subset(df, !grepl("ENTRADA|SALIDA", df$Cantidad, ignore.case = TRUE))
df <- subset(df, !grepl("ENTRADA|SALIDA", df$Producto, ignore.case = TRUE))

cabecera <- df %>%
  group_by(Supermercado, Calle, CP, Ubicacion, Telefono, Fecha, Hora, Total) %>%
  summarise(parking = any(parking))

Productos <- df %>% select(Cantidad, Producto, precio_prod)

Productos <- Productos %>%
  filter(!grepl("PARKING", Producto, ignore.case = TRUE))
```

Para finalizar la imputación de datos, se identifican las líneas que contienen pesos de productos y se asocian a su nombre correspondiente, dando lugar a tres dataframes finales: uno con los productos, otro con la información general y un tercero con todos los datos integrados.

```{r, echo =FALSE, warning=FALSE, message=FALSE}

library(dplyr)
library(stringr)

# 1) Localizamos las filas con "kg"
indices_kg <- which(str_detect(Productos$Producto, "kg"))

# 2) Para cada "kg", combinamos con la línea anterior
prod_anteriores <- Productos$Producto[indices_kg - 1]
productos_con_peso_precio <- paste(prod_anteriores, Productos$Producto[indices_kg], sep = ", ")

# 3) Reemplazamos la línea anterior por la combinada
Productos$Producto[indices_kg - 1] <- productos_con_peso_precio

# 4) Eliminamos las líneas originales que solo tenían la parte "kg"
Productos <- slice(Productos, -indices_kg)

# 5) Convertimos Cantidad a numérico
Productos$Cantidad <- as.numeric(Productos$Cantidad)

# 6) Arreglamos el nombre de la columna Telefono en cabecera
cabecera$Telefono <- gsub("TELÉFONO: ", "", cabecera$Telefono)


```
1. ¿Cuáles son los 5 productos, de los vendidos por unidades, con más ventas ? ¿Cuántas unidades de cada uno se han vendido ?

2. Si consideramos la categoría de FRUTAS Y VERDURAS. Cuáles son los 5 productos más vendidos ? ¿Cuántos kilos se han vendido de cada uno de estos productos ?

3. Si consideramos la categoría de PESCADO. Cuáles son los 5 productos más vendidos ? ¿Cuántos kilos se han vendido de cada uno de estos productos ?

4. Muestra mediante un gráfico de líneas como ha variado el precio por kilo de las bananas y los plátanos en los tickets disponibles, a lo largo del tiempo.

5. ¿ Cuál es la procedencia de los tickets ?¿ Qué ciudad/ pueblo tiene un mayor número de tickets ?

6. Muestra mediante un diagrama el número de tickets recogidos cada día de las semana. ¿Si tuvieses que cerrar un día entre semana qué día lo harías ?

Preguntas propuestas:

1. ¿Cuál es el promedio de productos por ticket?
2. ¿Qué categoría representa el mayor porcentaje del gasto total?
3. ¿Qué días de la semana concentran más compras?
4. ¿Cuáles son los 5 productos más baratos comprados por unidad? ¿Con qué frecuencia se compran?
5. ¿Qué porcentaje del gasto total se ha destinado a productos no alimentarios? ¿Qué tipo de productos destacan en ese grupo?
## Preguntas Obligatorias

#1. ¿Cuáles son los 5 productos, de los vendidos por unidades, con más ventas ? ¿Cuántas unidades de cada uno se han vendido ?
```{r}
unitarios %>%
  filter(str_detect(Productos, regex("ATUN CLARO OLIVA", ignore_case = TRUE))) %>%
  distinct(Productos)


top5_unitarios_limpios <- unitarios %>%
  mutate(
    # quitamos cualquier palabra final (suelo ser el precio),
    # es decir, desde el último espacio hasta el final
    Producto_limpio = str_squish(str_remove(Productos, "\\s+[^\\s]+$"))
  ) %>%
  group_by(Producto_limpio) %>%
  summarise(unidades_vendidas = sum(Cantidad, na.rm = TRUE), .groups = "drop") %>%
  arrange(desc(unidades_vendidas)) %>%
  slice_head(n = 5)

top5_unitarios_limpios

# Gráfico de barras horizontales ordenado
ggplot(top5_unitarios_limpios, 
       aes(x = reorder(Producto_limpio, unidades_vendidas), 
           y = unidades_vendidas)) +
  geom_col(fill = "lightgreen") +
  coord_flip() +
  labs(
    title    = "Top 5 productos vendidos por unidades",
    subtitle = "Unidades vendidas totales",
    x        = "Producto",
    y        = "Unidades vendidas"
  ) +
  theme_minimal()

```

## Preguntas Propuestas 
# 1. ¿Cuál es el promedio de productos por ticket?
```{r}


# Suponiendo que 'df' tiene todas las filas de productos con sus columnas de cabecera:
promedio_por_ticket <- df %>%
  # Agrupar por un identificador único de ticket; aquí usamos todas las columnas de cabecera
  group_by(Supermercado, Calle, CP, Ubicacion, Telefono, Fecha, Hora) %>%
  summarise(n_productos = n(), .groups = "drop") %>%
  summarise(promedio = mean(n_productos))

promedio_por_ticket

```
```{r}


# 1) Calcular nº de productos por ticket
tickets_productos <- df %>% 
  group_by(Supermercado, Calle, CP, Ubicacion, Telefono, Fecha, Hora) %>%
  summarise(n_productos = n(), .groups = 'drop')

# 2) Calcular la media
media_prod <- mean(tickets_productos$n_productos)

# 3) Graficar
ggplot(tickets_productos, aes(x = n_productos)) +
  geom_histogram(binwidth = 1, fill = "pink", color = "white") +
  geom_vline(xintercept = media_prod, linetype = "dashed", linewidth = 1) +
  labs(
    title    = "Distribución de productos por ticket",
    subtitle = paste0("Media = ", round(media_prod, 2), " productos"),
    x        = "Número de productos",
    y        = "Cantidad de tickets"
  ) +
  theme_minimal()

```


